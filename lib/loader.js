/*
 * Copyright (c) 2013, Yahoo! Inc.  All rights reserved.
 * Copyrights licensed under the New BSD License.
 * See the accompanying LICENSE file for terms.
 */

/*jslint node: true, nomen: true */

/**
The `yui.loader` extension exposes a locator plugin to build and register yui meta modules
from shifter module metadata.

@module yui
@submodule loader
**/

"use strict";

var path = require('path'),
    utils = require('./utils');

/**
The `yui.loader` extension exposes a locator plugin to build and register yui modules
and metadata.

Here is an example:

    var plugin = yui.locatorLoader({});

You can also specify whether or not the bundles should be registered as a group on loader
and modules in a bundle should be attached into a Y instance created for the server side.

    var plugin = yui.locatorLoader({
        register: true,
        attach: true
    });

@class loader
@static
@uses *path, utils, shifter
@extensionfor yui
*/
module.exports = {

    /**
    Registers information about modules that will be used
    to generate the bundle meta.

    @method register
    @protected
    @param {string} bundleName The bundle name to be registered.
    @param {string} cacheKey The cache key for the file that generates mod.
    @param {Object} mod The module information generated by the shifter module.
    **/
    register: function (bundleName, cacheKey, mod) {
        this._bundles = this._bundles || {};
        this._bundles[bundleName] = this._bundles[bundleName] || {};
        this._bundles[bundleName][cacheKey] = mod;
    },

    /**
    Creates a locator plugin that can analyze locator bundles and build the loader
    metadata for all yui modules within the bundle.

    @method locatorLoader
    @public
    @param {Object} options Optional plugin configuration
    objects that, if passed, will be mix with the default
    configuration of the plugin.

        @param {Boolean} register Whether or not the bundle should be registered as
        a loader group to be used from the client and server.
        @param {Boolean} attach Whether or not all the modules in the bundle should
        be attached into the Y instance on the server side.
        @param {string} yuiBuildDirectory Optional custom path for the output of the shifter

    @return {object} locator plugin
    **/
    locatorLoader: function (options) {

        var yui = this;

        options = options || {};

        return {

            describe: utils.extend({
                summary: 'Plugin to build YUI Loader metadata for a bundle',
                types: ['*'],
                shifterBuildArgs: ['--no-coverage', '--no-lint', '--silent', '--quiet', '--no-global-config']
            }, options),

            bundleUpdated: function (evt, api) {

                var self = this,
                    bundle = evt.bundle,
                    bundleName = bundle.name,
                    moduleName = 'loader-' + bundleName,
                    destination_path = moduleName + '.js',
                    meta,
                    contents,
                    obj,
                    builds;

                if (!bundle.yuiBuildDirectory) {
                    // augmenting bundle obj with more metadata about yui
                    bundle.yuiBuildDirectory = path.resolve(bundle.buildDirectory,
                            options.yuiBuildDirectory || 'yui-build');
                }

                builds = yui._buildsInBundle(bundleName, evt.files, api.getBundleFiles(bundleName, { extensions: 'json' }));

                meta = yui._bundles && yui._bundles[bundleName];

                if (!meta || builds.length === 0) {
                    // this bundle does not have any yui module registered
                    return;
                }

                return api.promise(function (fulfilled, rejected) {

                    // synthetically creating the meta for the meta module
                    meta[moduleName] = meta[moduleName] || {
                        name: moduleName,
                        buildfile: destination_path,
                        builds: {}
                    };
                    meta[moduleName].builds[moduleName] = {
                        name: moduleName,
                        config: {}
                    };

                    obj = new (yui.BuilderClass)({
                        name: moduleName,
                        group: bundleName
                    });
                    obj.compile(meta);

                    contents = obj.data.js;

                    return api.writeFileInBundle(bundleName, destination_path, contents).then(function (newfile) {

                        // automatically registering new groups in yui if needed
                        if (options.register) {
                            yui.registerGroup(bundle.name, bundle.yuiBuildDirectory, newfile);
                            // automatically attaching modules into a server instance if needed
                            if (options.attach) {
                                // removing the meta module from the list since it is not
                                // needed on the server side
                                // TODO: delete is evil, find another way
                                delete obj.data.json[moduleName];
                                yui.attachModules(bundleName, obj.data.json);
                            }
                        }

                        // adding the new meta module into the builds collection
                        builds.push(newfile);
                        yui.shiftFiles(builds, bundle.yuiBuildDirectory, self.describe.shifterBuildArgs, function (e) {
                            if (e) {
                                rejected(e);
                                return;
                            }
                            fulfilled();
                        });

                    }, rejected);

                });

            }

        };

    },

    _buildsInBundle: function (bundleName, modified, jsonFiles) {
        var self = this,
            file,
            skip,
            dir,
            mod,
            i,
            j,
            builds = [];

        // looking for yui modules
        for (i in modified) {
            if (modified.hasOwnProperty(i)) {
                file = modified[i].fullPath;
                // there is not need to add loader meta module into builds collection
                if (path.extname(file) === '.js' && path.basename(file) !== 'loader-' + bundleName + '.js') {
                    mod = this._checkYUIModule(file);
                    if (mod) {
                        this.register(bundleName, file, mod);
                        builds.push(file);
                    }
                }
            }
        }

        // looking for build.json
        for (i in jsonFiles) {
            if (jsonFiles.hasOwnProperty(i) && path.basename(jsonFiles[i]) === 'build.json') {
                mod = this._checkBuildFile(jsonFiles[i]);
                if (mod) {
                    skip = !modified[jsonFiles[i]];
                    dir = path.dirname(jsonFiles[i]);
                    for (j = 0; j <= modified.length; j += 1) {
                        if (path.extname(modified[j]) === '.js' && modified[j].indexOf(dir) === 0) {
                            // if there is a build.json that has at least a modified js in the range, we should not skip
                            skip = false;
                        }
                    }
                    this.register(bundleName, jsonFiles[i], mod);
                    // build only if at least one file from modified is under the dirname of build.json, or
                    // build.json was modified
                    if (!skip) {
                        builds.push(jsonFiles[i]);
                    }
                }
            }
        }

        return builds;
    }

};