/*
 * Copyright (c) 2013, Yahoo! Inc.  All rights reserved.
 * Copyrights licensed under the New BSD License.
 * See the accompanying LICENSE.txt file for terms.
 */

/*jslint nomen:true, node:true */

"use strict";

var fs = require('fs'),
    path = require('path'),
    utils = require('./utils'),
    existsSync = fs.existsSync || path.existsSync,
    TEMPLATE_TOKEN = '{ /* METAGEN */ }',
    crypto = require('crypto'),
    md5 = function (str) {
        var md5sum = crypto.createHash('md5');
        md5sum.update(str);
        return md5sum.digest('hex');
    };

function Builder(options) {
    this.name = options.name;
    this.group = options.group;
}

Builder.prototype = {
    data: {
        json: {},
        conds: {},
        files: null,
        mods: []
    },
    compile: function (mods) {
        this.process(mods);
        this.produceJSON();
        this.conditionals();
        this.produceJS();
    },
    process: function (mods) {
        var self = this;
        Object.keys(mods).forEach(function (key) {
            var mod = mods[key],
                i;
            for (i in mod.builds) {
                if (mod.builds.hasOwnProperty(i)) {
                    self.parseData(i, mod.builds[i].config || {}, mod.buildfile);
                }
            }
        });
    },
    parseData: function (name, data, file) {
        var i, o;
        for (i in data) {
            if (data.hasOwnProperty(i)) {
                if (i === 'submodules' || i === 'plugins') {
                    for (o in data[i]) {
                        if (data[i].hasOwnProperty(o)) {
                            this.parseData(o, data[i][o], file);
                        }
                    }
                    delete data[i];
                }
                if (i === 'condition') {
                    if (data[i].test && data[i].test.indexOf('.js') > 0) {
                        this.data.conds[name] = path.join(path.dirname(file), data[i].test);
                    }
                    data[i].name = name;
                    data[i] = this.sortObject(data[i]);
                }
            }
        }
        if (this.group) {
            data.group = this.group;
        }
        this.data.json[name] = this.sortObject(data);
    },
    sortObject: function (data) {
        var keys = Object.keys(data).sort(),
            d = {};
        keys.forEach(function (k) {
            d[k] = data[k];
        });
        return d;
    },
    conditionals: function () {
        var tests = [],
            allTests = [],
            jsonStr,
            self = this;

        Object.keys(this.data.json).forEach(function (name) {
            var mod = self.data.json[name],
                file,
                cond,
                cName,
                test;
            if (mod.condition) {
                cond = self.sortObject(mod.condition);
                if (self.data.conds[mod.condition.name]) {
                    cName = mod.condition.name;
                    file = self.data.conds[cName];
                    if (existsSync(file)) {
                        test = fs.readFileSync(file, 'utf8');
                        mod.condition.test = md5(file);
                        cond.test = test;
                        tests.push({ key: md5(file), test: test });
                    } else {
                        throw new Error('Failed to locate test file: ' + file);
                    }
                }
                allTests.push(cond);
            }
        });

        jsonStr = JSON.stringify(this.data.json, null, 4);

        tests.forEach(function (info) {
            jsonStr = jsonStr.replace('"' + info.key + '"', info.test);
        });

        jsonStr = jsonStr.replace(/\}\n,/g, '},').replace(/\}\n\n,/g, '},');

        this.data.jsonStr = jsonStr;
        this.data.tests = allTests;

    },
    produceJSON: function () {
        this.data.json = this.sortObject(this.data.json);
    },
    produceJS: function () {
        this.data.js = this.header().replace(TEMPLATE_TOKEN, this.data.jsonStr);
    },
    loadTests: function () {
        var str = [
            '/* This file is auto-generated by locator plugin yui-meta for bundle ' + this.group + ' */',
            '/*jshint maxlen:900, eqeqeq: false */',
            'var add = Y.Features.add;',
            ''
        ];
        return str.join('\n');
    },
    header: function () {
        var str = [
            '/* This file is auto-generated by locator plugin modown-yui for bundle ' + this.group + ' */',
            '',
            '/*jshint maxlen:900, eqeqeq: false */',
            '',
            '/**',
            ' * YUI 3 module metadata',
            ' * @module ' + this.name,
            ' */'
        ];

        str.push('YUI.Env[Y.version].modules = YUI.Env[Y.version].modules || {};');
        str.push('Y.mix(YUI.Env[Y.version].modules, { /* METAGEN */ });');

        str.unshift('YUI.add("' + this.name + '", function(Y, NAME) {');
        str.push('});');

        return str.join('\n');
    }
};

module.exports = {

    register: function (bundleName, cacheKey, mod) {
        this._bundles = this._bundles || {};
        this._bundles[bundleName] = this._bundles[bundleName] || {};
        this._bundles[bundleName][cacheKey] = mod;
    },

    locatorLoader: function (options) {

        var yui = this;

        return {

            describe: utils.extend({
                summary: 'Plugin to build YUI Loader metadata for a bundle',
                types: ['templates']
            }, options || {}),

            _bundles: {},

            bundleUpdated: function (bundle, api) {

                var self = this,
                    bundleName = bundle.name,
                    destination_path = 'loader.js',
                    contents,
                    obj;

                obj = new Builder({
                    name: 'loader-' + bundleName,
                    group: bundleName
                });

                // TODO: try/catch
                obj.compile(yui._bundles[bundleName]);
                contents = obj.data.js;

                return api.storeInCache(bundleName + destination_path, contents).then(function (cache) {

                    if (cache && !cache.updated) {
                        api.log('skipping meta generation for bundle ' + bundleName, 'debug', 'modown-yui');
                        return api.processFileInBundle(bundleName, destination_path);
                    }

                    return api.writeFileInBundle(bundleName, destination_path, contents);

                });

            }

        };

    }

};