/*
 * Copyright (c) 2013, Yahoo! Inc.  All rights reserved.
 * Copyrights licensed under the New BSD License.
 * See the accompanying LICENSE file for terms.
 */

/*jslint node: true, nomen: true */

/**
The `yui.loader` extension exposes a locator plugin to build and register yui meta modules
from shifter module metadata.

@module yui
@submodule loader
**/

"use strict";

var fs = require('fs'),
    path = require('path'),
    utils = require('./utils'),
    existsSync = fs.existsSync || path.existsSync,
    TEMPLATE_TOKEN = '{ /* METAGEN */ }',
    crypto = require('crypto'),
    md5 = function (str) {
        var md5sum = crypto.createHash('md5');
        md5sum.update(str);
        return md5sum.digest('hex');
    };

function Builder(options) {
    this.name = options.name;
    this.group = options.group;
}

Builder.prototype = {
    data: {
        json: {},
        conds: {},
        files: null,
        mods: []
    },
    compile: function (mods) {
        this.process(mods);
        this.produceJSON();
        this.conditionals();
        this.produceJS();
    },
    process: function (mods) {
        var self = this;
        Object.keys(mods).forEach(function (key) {
            var mod = mods[key],
                i;
            for (i in mod.builds) {
                if (mod.builds.hasOwnProperty(i)) {
                    self.parseData(i, mod.builds[i].config || {}, mod.buildfile);
                }
            }
        });
    },
    parseData: function (name, data, file) {
        var i, o;
        for (i in data) {
            if (data.hasOwnProperty(i)) {
                if (i === 'submodules' || i === 'plugins') {
                    for (o in data[i]) {
                        if (data[i].hasOwnProperty(o)) {
                            this.parseData(o, data[i][o], file);
                        }
                    }
                    delete data[i];
                }
                if (i === 'condition') {
                    if (data[i].test && data[i].test.indexOf('.js') > 0) {
                        this.data.conds[name] = path.join(path.dirname(file), data[i].test);
                    }
                    data[i].name = name;
                    data[i] = this.sortObject(data[i]);
                }
            }
        }
        if (this.group) {
            data.group = this.group;
        }
        this.data.json[name] = this.sortObject(data);
    },
    sortObject: function (data) {
        var keys = Object.keys(data).sort(),
            d = {};
        keys.forEach(function (k) {
            d[k] = data[k];
        });
        return d;
    },
    conditionals: function () {
        var tests = [],
            allTests = [],
            jsonStr,
            self = this;

        Object.keys(this.data.json).forEach(function (name) {
            var mod = self.data.json[name],
                file,
                cond,
                cName,
                test;
            if (mod.condition) {
                cond = self.sortObject(mod.condition);
                if (self.data.conds[mod.condition.name]) {
                    cName = mod.condition.name;
                    file = self.data.conds[cName];
                    if (existsSync(file)) {
                        test = fs.readFileSync(file, 'utf8');
                        mod.condition.test = md5(file);
                        cond.test = test;
                        tests.push({ key: md5(file), test: test });
                    } else {
                        throw new Error('Failed to locate test file: ' + file);
                    }
                }
                allTests.push(cond);
            }
        });

        jsonStr = JSON.stringify(this.data.json, null, 4);

        tests.forEach(function (info) {
            jsonStr = jsonStr.replace('"' + info.key + '"', info.test);
        });

        jsonStr = jsonStr.replace(/\}\n,/g, '},').replace(/\}\n\n,/g, '},');

        this.data.jsonStr = jsonStr;
        this.data.tests = allTests;

    },
    produceJSON: function () {
        this.data.json = this.sortObject(this.data.json);
    },
    produceJS: function () {
        this.data.js = this.header().replace(TEMPLATE_TOKEN, this.data.jsonStr);
    },
    loadTests: function () {
        var str = [
            '/* This file is auto-generated by locator plugin yui-meta for bundle ' + this.group + ' */',
            '/*jshint maxlen:900, eqeqeq: false */',
            'var add = Y.Features.add;',
            ''
        ];
        return str.join('\n');
    },
    header: function () {
        var str = [
            '/* This file is auto-generated by locator plugin modown-yui for bundle ' + this.group + ' */',
            '',
            '/*jshint maxlen:900, eqeqeq: false */',
            '',
            '/**',
            ' * YUI 3 module metadata',
            ' * @module ' + this.name,
            ' */'
        ];

        str.push('YUI.Env[Y.version].modules = YUI.Env[Y.version].modules || {};');
        str.push('Y.mix(YUI.Env[Y.version].modules, { /* METAGEN */ });');

        str.unshift('YUI.add("' + this.name + '", function(Y, NAME) {');
        str.push('});');

        return str.join('\n');
    }
};

/**
The `yui.loader` extension exposes a locator plugin to build and register yui meta modules
from shifter module metadata.

Here is an example:

    var plugin = yui.locatorLoader({});

You can also specify whether or not the bundles should be registered as a group on loader
and modules in a bundle should be attached into a Y instance created for the server side.

    var plugin = yui.locatorLoader({
        register: true,
        attach: true
    });

@class loader
@static
@uses *path, *fs, *crypto, utils
@extensionfor yui
*/
module.exports = {

    /**
    Registers information generated by the shifter module that will be used
    to generate the bundle meta.

    @method register
    @protected
    @param {string} bundleName The bundle name to be registered.
    @param {string} cacheKey The cache key for the file that generates mod.
    @param {Object} mod The module information generated by the shifter module.
    **/
    register: function (bundleName, cacheKey, mod) {
        this._bundles = this._bundles || {};
        this._bundles[bundleName] = this._bundles[bundleName] || {};
        this._bundles[bundleName][cacheKey] = mod;
    },

    /**
    Creates a locator plugin that can analyze locator bundles and build the loader
    metadata for all yui modules within the bundle.

    @method locatorLoader
    @public
    @param {Object} options Optional plugin configuration
    objects that, if passed, will be mix with the default
    configuration of the plugin.

        @param {Boolean} register Whether or not the bundle should be registered as
        a loader group to be used from the client and server.
        @param {Boolean} attach Whether or not all the modules in the bundle should
        be attached into the Y instance on the server side.

    @return {object} locator plugin
    **/
    locatorLoader: function (options) {

        var yui = this;

        options = options || {};

        return {

            describe: utils.extend({
                summary: 'Plugin to build YUI Loader metadata for a bundle',
                types: ['templates']
            }, options),

            _bundles: {},

            bundleUpdated: function (bundle, api) {

                var self = this,
                    bundleName = bundle.name,
                    moduleName = 'meta/' + bundleName,
                    destination_path = 'loader.js',
                    meta = yui._bundles[bundleName],
                    contents,
                    obj,
                    modules;

                if (!yui._bundles[bundleName]) {
                    // this bundle does not have any yui module registered
                    return;
                }

                obj = new Builder({
                    name: moduleName,
                    group: bundleName
                });

                // synthetically creating the meta for the meta module
                meta[moduleName] = meta[moduleName] || {
                    name: moduleName,
                    buildfile: destination_path,
                    builds: {}
                };
                meta[moduleName].builds[moduleName] = {
                    name: moduleName,
                    config: {}
                };

                // TODO: try/catch
                obj.compile(meta);

                contents = obj.data.js;
                modules = Object.keys(obj.data.json);

                return api.writeFileInBundle(bundleName, destination_path, contents).then(function (newfile) {

                    // automatically registering new groups in yui if needed
                    if (options.register) {
                        yui.registerGroup(bundle.name, bundle.yuiBuildDirectory, newfile);
                        // automatically attaching modules into a server instance if needed
                        if (options.attach) {
                            // removing the meta module from the list since it is not
                            // needed on the server side
                            // TODO: delete is evil, find another way
                            delete obj.data.json[moduleName];
                            yui.attachModules(bundleName, obj.data.json);
                        }
                    }

                });

            }

        };

    }

};