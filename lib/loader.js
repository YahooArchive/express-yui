/*
 * Copyright (c) 2013, Yahoo! Inc.  All rights reserved.
 * Copyrights licensed under the New BSD License.
 * See the accompanying LICENSE file for terms.
 */

/*jslint node: true, nomen: true */

/**
The `yui.loader` extension exposes a locator plugin to build and register yui meta modules
from shifter module metadata.

@module yui
@submodule loader
**/

"use strict";

var path = require('path'),
    utils = require('./utils');

/**
The `yui.loader` extension exposes a locator plugin to build and register yui modules
and metadata.

Here is an example:

    var plugin = yui.locatorLoader({});

You can also specify whether or not the bundles should be registered as a group on loader
and modules in a bundle should be attached into a Y instance created for the server side.

    var plugin = yui.locatorLoader({
        register: true,
        attach: true
    });

@class loader
@static
@uses *path, utils, shifter
@extensionfor yui
*/
module.exports = {

    /**
    Registers information about modules that will be used
    to generate the bundle meta.

    @method register
    @protected
    @param {string} bundleName The bundle name to be registered.
    @param {string} cacheKey The cache key for the file that generates mod.
    @param {Object} mod The module information generated by the shifter module.
    **/
    register: function (bundleName, cacheKey, mod) {
        this._bundles = this._bundles || {};
        this._bundles[bundleName] = this._bundles[bundleName] || {};
        this._bundles[bundleName][cacheKey] = mod;
    },

    /**
    Creates a locator plugin that can analyze locator bundles, build modules
    and build loader metadata for all yui modules within the bundle.

    @method plugin
    @public
    @param {Object} options Optional plugin configuration
    objects that, if passed, will be mix with the default
    configuration of the plugin.

        @param {Boolean} options.register Whether or not the bundle should be registered as
        a loader group to be used from the client and server. Default to false.
        @param {Boolean} options.attach Whether or not all the modules in the bundle should
        be attached into the Y instance on the server side. Default to false.
        @param {Boolean} options.cache Whether or not the shifting process should be cached to
        speed up the build process. By default, it is true.
        @param {string} options.buildDir Optional custom filesystem path for the output folder
        of the shifter. Default to an internal computation based on `locator.buildDir`.
        @param {object} options.args Optional shifter cli arguments. Defaults to
        `['--no-coverage', '--no-lint', '--silent', '--quiet', '--no-global-config']`

    @return {object} locator plugin
    **/
    plugin: function (options) {

        var yui = this;

        options = options || {};

        return {

            describe: utils.extend({
                summary: 'Plugin to build YUI Loader metadata for a bundle',
                types: ['*'],
                cache: true,
                args: ['--no-coverage', '--no-lint', '--silent', '--quiet', '--no-global-config']
            }, options),

            bundleUpdated: function (evt, api) {

                var self = this,
                    bundle = evt.bundle,
                    bundleName = bundle.name,
                    moduleName = 'loader-' + bundleName,
                    destination_path = moduleName + '.js',
                    meta,
                    contents,
                    obj,
                    builds,
                    files,
                    build;

                if (!bundle.yuiBuildDirectory) {
                    // augmenting bundle obj with more metadata about yui
                    bundle.yuiBuildDirectory = options.buildDir || path.resolve(bundle.buildDirectory, 'yui-build');
                }
                // getting the fullPath of all modified files in a form of an array
                files = Object.keys(evt.files || {}).map(function (i) {
                    return evt.files[i].fullPath;
                });
                builds = yui._buildsInBundle(bundleName, files, api.getBundleFiles(bundleName, { extensions: 'json' }));

                meta = yui._bundles && yui._bundles[bundleName];

                if (!meta || builds.length === 0) {
                    // this bundle does not have any yui module registered
                    return;
                }

                return api.promise(function (fulfilled, rejected) {

                    // synthetically creating the meta for the meta module
                    meta[moduleName] = meta[moduleName] || {
                        name: moduleName,
                        buildfile: destination_path,
                        builds: {}
                    };
                    meta[moduleName].builds[moduleName] = {
                        name: moduleName,
                        config: {}
                    };

                    obj = new (yui.BuilderClass)({
                        name: moduleName,
                        group: bundleName
                    });
                    obj.compile(meta);

                    contents = obj.data.js;

                    return api.writeFileInBundle(bundleName, destination_path, contents).then(function (newfile) {

                        // automatically registering new groups in yui if needed
                        if (options.register) {
                            yui.registerGroup(bundle.name, bundle.yuiBuildDirectory, newfile);
                            // automatically attaching modules into a server instance if needed
                            if (options.attach) {
                                // removing the meta module from the list since it is not
                                // needed on the server side
                                // TODO: delete is evil, find another way
                                delete obj.data.json[moduleName];
                                yui.attachModules(bundleName, obj.data.json);
                            }
                        }

                        // adding the new meta module into the builds collection
                        builds.push(newfile);
                        yui.shiftFiles(builds, {
                            buildDir: bundle.yuiBuildDirectory,
                            args: self.describe.args,
                            cache: self.describe.cache
                        }, function (e) {
                            if (e) {
                                rejected(e);
                                return;
                            }
                            fulfilled();
                        });

                    }, rejected);

                });

            }

        };

    },

    /**
    Analyze modified files and build.json files to infer the list of files that
    should be shfited.

    @method _buildsInBundle
    @protected
    @param {string} bundleName The bundle name to be registered.
    @param {array} modifiedFiles The filesystem path for all modified files in bundle.
    @param {array} jsonFiles The filesystem path for all json files in bundle.
    @return {array} The filesystem path for all files that should be shifted using shifter
    **/
    _buildsInBundle: function (bundleName, modifiedFiles, jsonFiles) {
        var self = this,
            file,
            skip,
            dir,
            mod,
            i,
            m,
            builds = [];

        modifiedFiles = modifiedFiles || [];
        jsonFiles = jsonFiles || [];

        // looking for modified yui modules
        for (m = 0; m < modifiedFiles.length; m += 1) {
            file = modifiedFiles[m];
            // there is not need to add loader meta module into builds collection
            if (path.extname(file) === '.js' && path.basename(file) !== 'loader-' + bundleName + '.js') {
                mod = this._checkYUIModule(file);
                if (mod) {
                    this.register(bundleName, file, mod);
                    builds.push(file);
                }
            }
        }

        // looking for build.json
        for (i = 0; i < jsonFiles.length; i += 1) {
            if (path.basename(jsonFiles[i]) === 'build.json') {
                mod = this._checkBuildFile(jsonFiles[i]);
                if (mod) {
                    skip = true;
                    dir = path.dirname(jsonFiles[i]);
                    for (m = 0; m < modifiedFiles.length; m += 1) {
                        file = modifiedFiles[m];
                        // if build.json itself was modified, we should not skip
                        if (file === jsonFiles[i]) {
                            skip = false;
                        }
                        // if there is a modified .js file in the range, we should not skip
                        if (path.extname(file) === '.js' && file.indexOf(dir) === 0) {
                            skip = false;
                        }
                    }
                    this.register(bundleName, jsonFiles[i], mod);
                    // build only if at least one file from modified is under the dirname of build.json, or
                    // build.json was modified
                    if (!skip) {
                        builds.push(jsonFiles[i]);
                    }
                }
            }
        }

        return builds;
    }

};