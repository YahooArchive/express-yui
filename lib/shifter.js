/*
 * Copyright (c) 2013, Yahoo! Inc.  All rights reserved.
 * Copyrights licensed under the New BSD License.
 * See the accompanying LICENSE file for terms.
 */

/*jslint node: true, nomen: true, stupid: true */

/**
The `yui.shifter` extension exposes a set of utilities to build yui modules
from *.js or build.json files.

@module yui
@submodule shifter
**/

'use strict';

var fs = require('fs'),
    path = require('path'),
    utils = require('./utils'),
    existsSync = fs.existsSync || path.existsSync,
    vm = require('vm'),
    spawn = require('win-spawn'),
    shifterCLI = path.join(__dirname, '../node_modules/shifter/bin/shifter'),
    NODE_ENV   = process.env.NODE_ENV || 'development',
    contextForRunInContext = vm.createContext({
        require: require,
        module: require('module'),
        console: {
            log: function () {}
        },
        window: {},
        document: {}
    }),
    TEMPLATE_TOKEN = '{ /* METAGEN */ }',
    crypto = require('crypto'),
    md5 = function (str) {
        var md5sum = crypto.createHash('md5');
        md5sum.update(str);
        return md5sum.digest('hex');
    };

function Builder(options) {
    this.name = options.name;
    this.group = options.group;
}

Builder.prototype = {
    data: {
        json: {},
        conds: {},
        files: null,
        mods: []
    },
    compile: function (mods) {
        this.process(mods);
        this.produceJSON();
        this.conditionals();
        this.produceJS();
    },
    process: function (mods) {
        var self = this;
        Object.keys(mods).forEach(function (key) {
            var mod = mods[key],
                i;
            for (i in mod.builds) {
                if (mod.builds.hasOwnProperty(i)) {
                    self.parseData(i, mod.builds[i].config || {}, mod.buildfile);
                }
            }
        });
    },
    parseData: function (name, data, file) {
        var i, o;
        for (i in data) {
            if (data.hasOwnProperty(i)) {
                if (i === 'submodules' || i === 'plugins') {
                    for (o in data[i]) {
                        if (data[i].hasOwnProperty(o)) {
                            this.parseData(o, data[i][o], file);
                        }
                    }
                    delete data[i];
                }
                if (i === 'condition') {
                    if (path.extname(data[i].test && (data[i].test) === '.js')) {
                        this.data.conds[name] = data[i].test;
                    }
                    data[i].name = name;
                    data[i] = this.sortObject(data[i]);
                }
            }
        }
        if (this.group) {
            data.group = this.group;
        }
        this.data.json[name] = this.sortObject(data);
    },
    sortObject: function (data) {
        var keys = Object.keys(data).sort(),
            d = {};
        keys.forEach(function (k) {
            d[k] = data[k];
        });
        return d;
    },
    conditionals: function () {
        var tests = [],
            allTests = [],
            jsonStr,
            self = this;

        Object.keys(this.data.json).forEach(function (name) {
            var mod = self.data.json[name],
                file,
                cond,
                cName,
                test;
            if (mod.condition) {
                cond = self.sortObject(mod.condition);
                if (self.data.conds[mod.condition.name]) {
                    cName = mod.condition.name;
                    file = self.data.conds[cName];
                    // TODO: make this async and remove the stupid flag
                    if (existsSync(file)) {
                        test = fs.readFileSync(file, 'utf8');
                        mod.condition.test = md5(file);
                        cond.test = test;
                        tests.push({ key: md5(file), test: test });
                    } else {
                        throw new Error('Failed to locate test file: ' + file);
                    }
                }
                allTests.push(cond);
            }
        });

        jsonStr = JSON.stringify(this.data.json, null, 4);

        tests.forEach(function (info) {
            jsonStr = jsonStr.replace('"' + info.key + '"', info.test);
        });

        jsonStr = jsonStr.replace(/\}\n,/g, '},').replace(/\}\n\n,/g, '},');

        this.data.jsonStr = jsonStr;
        this.data.tests = allTests;

    },
    produceJSON: function () {
        this.data.json = this.sortObject(this.data.json);
    },
    produceJS: function () {
        this.data.js = this.header().replace(TEMPLATE_TOKEN, this.data.jsonStr);
    },
    loadTests: function () {
        var str = [
            '/* This file is auto-generated by locator plugin yui-meta for bundle ' + this.group + ' */',
            '/*jshint maxlen:900, eqeqeq: false */',
            'var add = Y.Features.add;',
            ''
        ];
        return str.join('\n');
    },
    header: function () {
        var str = [
            '/* This file is auto-generated by locator plugin modown-yui for bundle ' + this.group + ' */',
            '',
            '/*jshint maxlen:900, eqeqeq: false */',
            '',
            '/**',
            ' * YUI 3 module metadata',
            ' * @module ' + this.name,
            ' */'
        ];

        str.push('YUI.Env[Y.version].modules = YUI.Env[Y.version].modules || {};');
        str.push('Y.mix(YUI.Env[Y.version].modules, { /* METAGEN */ });');

        str.unshift('YUI.add("' + this.name + '", function(Y, NAME) {');
        str.push('});');

        return str.join('\n');
    }
};

/**
The `yui.shifter` extension exposes a locator plugin to build yui modules
from *.js or build.json files.

Here is an example:

    var plugin = yui.locatorShifter({});

You can also specify a custom yui build directory, by doing:

    var plugin = yui.locatorShifter({
        yuiBuildDirectory: '/path/to/folder'
    });

@class shifter
@static
@uses *path, *fs, *module, *vm, utils, win-spawn, shifter, loader
@extensionfor yui
*/
module.exports = {

    /**
    Shift yui modules using shifter cli.

    @method shiftFiles
    @public
    @param {array} files filesystem paths for all files to be shifted
    @param {string} yuiBuildDirectory custom path for the output of the shifter
    @param {array} shifterBuildArgs custom shifter build arguments, it defaults to
        ['--no-coverage', '--no-lint', '--silent', '--quiet', '--no-global-config']
    @param {function} callback the callback method to signal the end of the operation
    **/
    shiftFiles: function (files, yuiBuildDirectory, shifterBuildArgs, callback) {

        var self = this,
            queue = [].concat(files),
            args,
            child,
            i;

        shifterBuildArgs = shifterBuildArgs || ['--no-coverage', '--no-lint', '--silent', '--quiet', '--no-global-config'];

        if (NODE_ENV === "production") {
            console.log('[modown-yui] skipping shifter in production environments.');
            if (callback) { callback(null); }
            return;
        }

        function next() {

            var file = queue.shift();

            if (file) {

                console.log('[modown-yui] shifting ' + file);

                args = [
                    shifterCLI,
                    "--build-dir", yuiBuildDirectory,
                    (path.extname(file) === '.js' ? '--yui-module' : '--config'), file
                ].concat(shifterBuildArgs);

                child = spawn(process.argv[0], args, {
                    cwd: path.dirname(file),
                    stdio: 'inherit'
                });
                child.on('exit', function (code) {
                    if (code) {
                        callback(new Error(file + ": shifter compiler error: " + code + '\n' +
                            ' while executing: \n' + args.join(' ')));
                        return;
                    }
                    next(); // next item in queue to be processed
                });

            } else {
                if (callback) { callback(null); }
            }

        }

        next(); // kick off the queue process

    },

    _checkBuildFile: function (file) {
        var mod,
            entry,
            metas = path.join(path.dirname(file), 'meta'),
            files,
            i,
            j,
            f;

        try {
            mod = JSON.parse(fs.readFileSync(file, 'utf8'));
        } catch (e1) {
            console.error('Failed to parse build file: ' + file);
            console.error(e1);
            return;
        }

        if (!mod.builds) {
            console.error('Invalid meta file: ' + file);
            return;
        }

        mod.buildfile = file;

        if (existsSync(metas)) {
            files = fs.readdirSync(metas);
            for (i = 0; i < files.length; i += 1) {
                f = files[i];
                if (path.extname(f) === '.json') {
                    try {
                        entry = JSON.parse(fs.readFileSync(path.join(metas, f), 'utf8'));
                    } catch (e2) {
                        console.error('Failed to parse meta file: ' + f);
                        console.error(e2);
                        return;
                    }
                    for (j in entry) {
                        if (entry.hasOwnProperty(j)) {
                            mod.builds[j] = mod.builds[j] || {};
                            mod.builds[j].config = entry[j];
                            // setting the proper filename for test if needed
                            if (entry[j] && entry[j].condition && entry[j].condition.test &&
                                    path.extname(entry[j].condition.test) === '.js') {
                                entry[j].condition.test = path.join(metas, entry[j].condition.test);
                            }
                        }
                    }
                }
            }
        }
        return mod;
    },

    _checkYUIModule: function (file) {
        var mod;

        contextForRunInContext.YUI = {
            add: function (name, fn, version, config) {
                if (!mod) {
                    mod = {
                        name: name,
                        buildfile: file,
                        builds: {}
                    };
                }
                mod.builds[name] = {
                    name: name,
                    config: config || {}
                };
            }
        };
        try {
            vm.runInContext(fs.readFileSync(file, 'utf8'), contextForRunInContext, file);
        } catch (e) {
            return;
        }
        return mod;
    },

    BuilderClass: Builder

};